{
"version":3,
"file":"module$node_modules$svgpath$lib$ellipse.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/svgpath/lib/ellipse.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$svgpath$lib$ellipse\"] = function(global,require,module,exports) {\n'use strict';\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [\n    this.rx * (m[0]*c + m[2]*s),\n    this.rx * (m[1]*c + m[3]*s),\n    this.ry * (-m[0]*s + m[2]*c),\n    this.ry * (-m[1]*s + m[3]*c)\n  ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  /*eslint-disable indent*/\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n  /*eslint-enable indent*/\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Ellipse","rx","ry","ax","torad","Math","PI","prototype","transform","Ellipse.prototype.transform","m","c","cos","s","sin","ma","J","K","D","JK","epsilon","sqrt","L","l1","l2","abs","atan","isDegenerate","Ellipse.prototype.isDegenerate"]
}
